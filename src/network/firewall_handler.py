#!/usr/bin/env python3
import os
import subprocess
import platform
import logging

class FirewallHandler:
    def __init__(self, iptables_rules_file="/etc/website_blocker/iptables_rules.sh"):
        self.iptables_rules_file = iptables_rules_file
        self.os_type = platform.system().lower()
    
    def update_firewall_rules(self, websites, blocked_ips, blocking=True):
        """Update firewall rules to block or unblock websites"""
        if not blocked_ips:
            logging.warning("No IP addresses to block with firewall")
            return False

        if self.os_type == "linux":
            return self._update_iptables_rules(blocked_ips, blocking)
        elif self.os_type == "darwin":  # macOS
            return self._update_pf_rules(blocked_ips, blocking)
        else:
            logging.warning(f"Firewall rules not implemented for {self.os_type}")
            return False
    
    def _is_command_available(self, command):
        """Check if a command is available on the system"""
        try:
            subprocess.run(["which", command], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            return True
        except Exception:
            return False
    
    def _update_iptables_rules(self, blocked_ips, blocking=True):
        """Update iptables rules to block or unblock websites on Linux"""
        if not self._is_command_available("iptables"):
            logging.warning("iptables not available, skipping firewall blocking")
            return False
            
        # Create the directory for the iptables rules script if it doesn't exist
        iptables_dir = os.path.dirname(self.iptables_rules_file)
        if not os.path.exists(iptables_dir):
            try:
                os.makedirs(iptables_dir, exist_ok=True)
            except Exception as e:
                logging.error(f"Failed to create directory for iptables rules script: {e}")
                return False
                
        try:
            # Create a script that will be used to apply and restore rules
            with open(self.iptables_rules_file, 'w') as f:
                f.write("#!/bin/sh\n\n")
                f.write("# Automatically generated by website blocker\n\n")
                
                # Clear existing rules for the website blocker chain
                f.write("# Clear existing rules\n")
                f.write("iptables -D OUTPUT -j WEBSITE_BLOCKER 2>/dev/null\n")
                f.write("iptables -F WEBSITE_BLOCKER 2>/dev/null\n")
                f.write("iptables -X WEBSITE_BLOCKER 2>/dev/null\n\n")
                
                if blocking:
                    # Create a new chain for the website blocker
                    f.write("# Create a new chain\n")
                    f.write("iptables -N WEBSITE_BLOCKER\n\n")
                    
                    # Add rules for each IP
                    f.write("# Add blocking rules\n")
                    for ip in blocked_ips:
                        f.write(f"iptables -A WEBSITE_BLOCKER -d {ip} -j REJECT\n")
                    
                    # Link the chain to the OUTPUT chain
                    f.write("\n# Link the chain to OUTPUT\n")
                    f.write("iptables -A OUTPUT -j WEBSITE_BLOCKER\n")
                
            # Make the script executable
            os.chmod(self.iptables_rules_file, 0o755)
            
            # Run the script
            subprocess.run([self.iptables_rules_file], 
                          stdout=subprocess.PIPE, 
                          stderr=subprocess.PIPE)
            
            if blocking:
                logging.info(f"Added iptables rules to block {len(blocked_ips)} IP addresses")
            else:
                logging.info("Removed iptables blocking rules")
                
            return True
            
        except Exception as e:
            logging.error(f"Failed to update iptables rules: {e}")
            return False
    
    def _update_pf_rules(self, blocked_ips, blocking=True):
        """Update pf firewall rules to block or unblock websites on macOS"""
        if not self._is_command_available("pfctl"):
            logging.warning("pfctl not available, skipping firewall blocking")
            return False
            
        # Check if pf is already enabled
        pf_status = subprocess.run(["pfctl", "-sa"], 
                                  stdout=subprocess.PIPE, 
                                  stderr=subprocess.PIPE, 
                                  text=True)
        
        pf_enabled = "Status: Enabled" in pf_status.stdout
        
        try:
            pf_rules_file = "/etc/website_blocker/pf.rules"
            pf_dir = os.path.dirname(pf_rules_file)
            
            # Create the directory if it doesn't exist
            if not os.path.exists(pf_dir):
                os.makedirs(pf_dir, exist_ok=True)
            
            if blocking:
                # Create pf rules file
                with open(pf_rules_file, 'w') as f:
                    f.write("# Automatically generated by website blocker\n\n")
                    f.write("block drop out proto {tcp udp} from any to {\n")
                    
                    # Add each IP address
                    for i, ip in enumerate(blocked_ips):
                        # Add a comma after every IP except the last one
                        if i < len(blocked_ips) - 1:
                            f.write(f"    {ip},\n")
                        else:
                            f.write(f"    {ip}\n")
                            
                    f.write("}\n")
                
                # Load the rules
                subprocess.run(["pfctl", "-ef", pf_rules_file], 
                              stdout=subprocess.PIPE, 
                              stderr=subprocess.PIPE)
                
                logging.info(f"Added pf rules to block {len(blocked_ips)} IP addresses")
                
            else:
                # Remove the rules file if it exists
                if os.path.exists(pf_rules_file):
                    os.remove(pf_rules_file)
                
                # Disable pf if it was not enabled before
                if not pf_enabled:
                    subprocess.run(["pfctl", "-d"], 
                                  stdout=subprocess.PIPE, 
                                  stderr=subprocess.PIPE)
                
                logging.info("Removed pf blocking rules")
            
            return True
            
        except Exception as e:
            logging.error(f"Failed to update pf rules: {e}")
            return False 